---
layout: post
title: "Base64"
date: 2017-06-17 17:04
image: ''
description: ''
tags:
- Base64
- Encoding
categories:
- Programming
---

# Base64
8비트 바이너리 데이터를 [문자코드](https://ko.wikipedia.org/wiki/%EB%AC%B8%EC%9E%90_%EC%9D%B8%EC%BD%94%EB%94%A9)(ASCII, 유니코드 등)에 상관없이 공통 ASCII 문자들로만 이루어진 일련의 문자열로 바꾸는 인코딩입니다.<br/>
Base64는 64진법을 사용하며, 64진법은 2의 제곱수인 2^6이며, 알파벳(A-Z, a-z), 숫자, 마지막 두 개의 어떤 기호의 순서로 총 64개로 구성되어있습니다.<br/>

Base64는 처음 설계될 때, 8비트 문자열을 6비트 문자열로 변경하기 위해 6과 8의 최소공배수(6과 8을 둘 다 만족하는 최소값)인 24 bit(=3 bytes)를 입력하면 4개의 문자열이 출력되도록 설계되었습니다.

![Base64 공식]({{ site.url }}/assets/images/post_image/{{ page.date | date: "%Y" }}/{{ page.date | date: "%m" }}/base64_formula.png)
위의 공식에 따라 1 byte를 입력하게 되면 4/3개의 문자열이 출력됩니다. 즉, 기존의 입력받는 문자열보다 Base64로 인코딩될 경우, **기존의 데이터보다 1.333배로 길이가 증가합니다.**<br/>
만약 3바이트 미만일 경우는 **'='**(2bit) 패딩문자를 채웁니다. <br/>
3바이트 미만인 경우의 수는 1 또는 2바이트만 존재하기 때문에 1바이트인 경우는 2bit가 남아서 패딩문자가 1개, 2바이트인 경우에는 4bit가 남아서 패딩문자를 2개만 채웁니다. <br/>
패딩문자를 채우는 이유는 **8비트를 6비트로 자르기 때문에 디코딩시 기존 데이터의 손실**이 일어날 수 있어서 패딩문자를 채워서 데이터 손실을 방지합니다.
<br/>

## Base64를 사용하는 이유
컴퓨터는 0과 1만으로 이루어진 2진수(기계어)만 이해할 수 있습니다. 컴퓨터가 A, B, C.. 등의 문자를 이해하기 위해서는 문자를 2진수로 변경을 해줘야하는데 각 문자에 숫자(10진수, 16진수를 사용)를 매칭해 규칙으로 정한 것을 'ASCII' 라고 합니다. <br/>
ASCII를 만들게된 이유는 초기 SMTP 프로토콜은 7비트로만 전송하게 설계되었습니다. ASCII 코드만 준수하면 SMTP 프로토콜에서 텍스트를 주고 받는데에는 전혀 문제가 없었지만, 사람들이 텍스트가 아닌 이미지, 문서파일 등등 바이너리 데이터를 전송해야될 경우가 생깁니다. <br/>
바이너리 데이터는 8비트로 되어있기 때문에 SMTP 프로토콜로 전송할 수가 없게 되어 8비트 이상의 코드를 전송하기 위해 인터넷 표준 포맷으로 [MIME](https://ko.wikipedia.org/wiki/MIME)가 만들어지게 됩니다. MIME에서 바이너리 데이터를 ASCII 텍스트 형식으로 변환하기 위한 방법 중 하나가 Base64 인코딩입니다.<br/>
간혹, 암호화할 때 Base64를 사용한다고 착각하시는 분들이 있습니다. Base64는 **암호화 방식이 아닌 인코딩 방식**입니다.
<br/>

## Base64 인코딩 방법
1. 문자에 해당하는 아스키코드로 변환.
2. 아스키코드를 2진수로 변환.
3. 변환한 2진수를 6비트씩 자르고 남는 비트는 0으로 채운다.
4. 2진수를 다시 10진수로 변환.
5. 10진수에 해당하는 Base64 코드값으로 변환.

**"Hong"** 이라는 문자를 Base64로 변환하는 방법은 다음과 같습니다.

처음에는 해당하는 문자에 대한 아스키코드값으로 변환합니다.

|H   |o   |n   |g   |
|:---|:---|:---|:---|
|72  |111 |110 |103 |


다음은 아스키코드값을 이진수로 변환합니다.

|72      |111     |110     |103     |
|:-------|:-------|:-------|:-------|
|01001000|01101111|01101110|01100111|

변환된 이진수를 6비트씩 끊어서 표현합니다. <br/>
괄호친 부분(0000)은 4비트라서 6비트로 만들기 위해 남는 부분은 '=' 로 채웁니다. <br/>

> 01001000  01101111  01101110  01100111 <br/>
> => 010010 000110 111101 101110 011001 11(0000)

6비트로 자른 값들을 10진수로 표현하여 10진수를 아래의 Base64 코드값으로 매칭시키면 인코딩 완료. <br/>

| 010010 | 000110 | 111101 | 101110 | 011001 | 11(0000) | 패딩 |
|--------|--------|--------|--------|--------|----------|------|
| 18     | 6      | 61     | 46     | 25     | 48       |패딩으로 채운 비트수 표시<br/>(4bit를 채웠다는 뜻)|
| S      | G      | 9      | u      | Z      | w        | ==|

**"Hong"** 이라는 문자를 Base64로 인코딩하면 **"SG9uZw=="** 가 됩니다.<br/>
디코딩은 위 내용을 거꾸로 진행하면 됩니다.

![Base64 색인표]({{ site.url }}/assets/images/post_image/{{ page.date | date: "%Y" }}/{{ page.date | date: "%m" }}/base64_index.png){:height="40%" width="40%"}

--------------------------------

# 참고
* [위키백과 - Base64](https://ko.wikipedia.org/wiki/%EB%B2%A0%EC%9D%B4%EC%8A%A464)
* [위키백과 - 8Bit Clean](https://en.wikipedia.org/wiki/8-bit_clean)
* [MIME(Multipurpose Internet Mail Extensions) - RFC2045](https://tools.ietf.org/html/rfc2045)
